{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import bokeh, bokeh.io, bokeh.plotting\n",
    "from bokeh.io import output_notebook, show\n",
    "import pandas as pd\n",
    "import matplotlib.colors\n",
    "import matplotlib.cm\n",
    "import os.path\n",
    "import glob\n",
    "import IPython.display\n",
    "from collections import defaultdict\n",
    "from external_coffeescript import build_callback\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "\n",
    "def build_selected(indices):\n",
    "    \"\"\"\n",
    "    Helper function needed for plotting scatter()\n",
    "    \"\"\"\n",
    "    pvd = bokeh.core.property.containers.PropertyValueDict\n",
    "    pvl = bokeh.core.property.containers.PropertyValueList\n",
    "\n",
    "    selected = pvd({\n",
    "        '0d': pvd({\n",
    "            'glyph': None,\n",
    "            'indices': pvl(),\n",
    "        }),\n",
    "        '1d': pvd({\n",
    "            'indices': pvl(indices),\n",
    "        }),\n",
    "        '2d': pvd(),\n",
    "    })\n",
    "\n",
    "    return selected\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def scatter(filename=None,\n",
    "            numerical_cols=None,\n",
    "            hover_keys=None,\n",
    "            table_keys=None,\n",
    "            color_by=None, \n",
    "            label_by=None, \n",
    "            size=600,\n",
    "            axis_label_size=20,\n",
    "            log_scale=False,\n",
    "            volcano=False,\n",
    "            heatmap=False,\n",
    "            grid='none',\n",
    "            marker_size=6,\n",
    "            initial_selection=None,\n",
    "            initial_xy_names=None,\n",
    "            data_lims=None,\n",
    "            zoom_to_initial_data=False,\n",
    "            alpha_widget_type='slider',\n",
    "            hide_widgets=None,\n",
    "            identical_bins=False,\n",
    "            num_bins=100,\n",
    "            return_layout=False,\n",
    "           ):\n",
    "    ''' Makes an interactive scatter plot using bokeh. Call without any\n",
    "    arguments for an example using data from Jan et al. Science 2014.\n",
    "\n",
    "    Args:\n",
    "            df: A pandas DataFrame with columns containing numerical data to\n",
    "                plot. \n",
    "                Index values will be used as labels for points.\n",
    "                Any text columns will be searchable through the 'Search:' field.\n",
    "                Any boolean columns will be used to define subsets of points for\n",
    "                selection from a dropdown menu.\n",
    "                If df is None, loads example data from Jan et al. Science 2014.\n",
    "\n",
    "            numerical_cols: If given, a list of columns to use as plotting\n",
    "                choices. (If not given, all columns containing numerical data\n",
    "                will be used.)\n",
    "\n",
    "            hover_keys: Names of columns in df to display in the tooltip that\n",
    "                appears when you hover over a point.\n",
    "\n",
    "            table_keys: Names of columns in df to display in the table below the\n",
    "                plot that is populated with the selected points from the figure.\n",
    "\n",
    "            color_by: The name of a column in df to use as colors of points, or\n",
    "                a list of such names to choose from a menu.\n",
    "            \n",
    "            label_by: The name of a column in df to use as labels of points, or\n",
    "                a list of such names to choose from a menu. If None, df.index\n",
    "                is used.\n",
    "\n",
    "            size: Size of the plot in pixels.\n",
    "\n",
    "            marker_size: Size of the scatter circles. Can be a scalar value, a\n",
    "                column name, or a list of column names to choose from via\n",
    "                dropdown menu.\n",
    "\n",
    "            heatmap: If True, displays a heatmap of correlations between\n",
    "                numerical columns in df that can be clicked to select columns\n",
    "                to scatter.\n",
    "\n",
    "            grid: Draw a 'grid', 'diagonal' lines, or 'none' as guide lines.\n",
    "\n",
    "            volcano: If True, make some tweaks suitable for volcano plots.\n",
    "\n",
    "            log_scale: If not False, plot on a log scale with base 10 (or, if a\n",
    "                set to a number, with base log_scale.)\n",
    "\n",
    "            axis_label_size: Size of the font used for axis labels.\n",
    "\n",
    "            initial_selection: Names of index value to initially highlight.\n",
    "\n",
    "            initial_xy_names: Tuple (x_name, y_name) of datasets to initially\n",
    "                display on x- and y-axes.\n",
    "\n",
    "            alpha_widget_type: Type of widget ('slider' or 'text') to control\n",
    "                scatter circle transparency.\n",
    "\n",
    "            hide_widgets: List of widgets to not display. Possible options are\n",
    "                ['table', 'alpha', 'marker_size', 'search', 'subset_menu',\n",
    "                 'grid_radio_buttons'].\n",
    "\n",
    "            identical_bins: If True, use the same set of bins for histograms of\n",
    "                all data sets. If False, use bins specific to the range of each\n",
    "                data set.\n",
    "\n",
    "            num_bins: Number of bins to use for marginal histograms.\n",
    "\n",
    "            zoom_to_initial_data: If True, zoom to data limits of the initially\n",
    "                selected columns rather than global data limits..\n",
    "\n",
    "            return_layout: If True, return the final layout object to allowing\n",
    "                embedding.\n",
    "    '''\n",
    "\n",
    "    if hover_keys is None:\n",
    "        hover_keys = []\n",
    "\n",
    "    if table_keys is None:\n",
    "        table_keys = []\n",
    "\n",
    "    if hide_widgets is None:\n",
    "        hide_widgets = set()\n",
    "    else:\n",
    "        hide_widgets = set(hide_widgets)\n",
    "\n",
    "    if volcano:\n",
    "        grid = 'grid'\n",
    "\n",
    "    \n",
    "\n",
    "    if filename is None:\n",
    "        # Load example data.\n",
    "        fn = os.path.join(os.path.dirname(__file__), 'example_df.txt')\n",
    "        df = pd.read_csv(fn, index_col='alias')\n",
    "\n",
    "        # Override some arguments.\n",
    "        log_scale = True\n",
    "        hover_keys = ['systematic_name', 'short_description']\n",
    "        table_keys = ['systematic_name', 'description']\n",
    "        grid = 'diagonal'\n",
    "        heatmap = False\n",
    "        identical_bins = False\n",
    "        volcano=False\n",
    "    else:\n",
    "        df=pd.DataFrame.from_csv(filename)\n",
    "    # Copy before changing\n",
    "    df = df.copy()\n",
    "\n",
    "    # Collapse multiindex if present\n",
    "    df.columns = [' '.join(n) if isinstance(n, tuple) else n for n in df.columns]\n",
    "\n",
    "    # Infer column types.\n",
    "    scatter_source = bokeh.models.ColumnDataSource(data=df, name='scatter_source')\n",
    "\n",
    "    if 'index' in scatter_source.data:\n",
    "        scatter_source.data['_index'] = scatter_source.data['index']\n",
    "\n",
    "    if df.index.name is None:\n",
    "        df.index.name = 'index'\n",
    "\n",
    "    if initial_selection is None:\n",
    "        initial_selection = []\n",
    "\n",
    "    initial_indices = [i for i, n in enumerate(df.index) if n in initial_selection]\n",
    "\n",
    "    auto_numerical_cols = [n for n in df.columns if df[n].dtype in [float, int]]\n",
    "    if numerical_cols is not None:\n",
    "        for col in numerical_cols:\n",
    "            if col not in auto_numerical_cols:\n",
    "                raise ValueError(col + ' not a numerical column')\n",
    "    else:\n",
    "        numerical_cols = auto_numerical_cols\n",
    "\n",
    "    object_cols = [n for n in df.columns if df[n].dtype is np.dtype('O')]\n",
    "    if df.index.dtype is np.dtype('O'):\n",
    "        object_cols.append(df.index.name)\n",
    "\n",
    "    bool_cols = [n for n in df.columns if df[n].dtype is np.dtype('bool')]\n",
    "\n",
    "    subset_indices = {n: [i for i, v in enumerate(df[n]) if v] for n in bool_cols}\n",
    "\n",
    "    # Set up the actual scatter plot.\n",
    "    \n",
    "    tools = [\n",
    "        'reset',\n",
    "        'undo',\n",
    "        'pan',\n",
    "        'box_zoom',\n",
    "        'box_select',\n",
    "        'tap',\n",
    "        'wheel_zoom',\n",
    "        'save',\n",
    "    ]\n",
    "    \n",
    "    fig_kwargs = dict(\n",
    "        plot_width=size,\n",
    "        plot_height=size,\n",
    "        tools=tools,\n",
    "        lod_threshold=10000,\n",
    "        name='scatter_fig',\n",
    "    )\n",
    "\n",
    "    min_border = 80\n",
    "\n",
    "    if log_scale == True:\n",
    "        log_scale = 10\n",
    "        fig_kwargs['y_axis_type'] = 'log'\n",
    "        fig_kwargs['x_axis_type'] = 'log'\n",
    "    \n",
    "    fig = bokeh.plotting.figure(**fig_kwargs)\n",
    "    fig.toolbar.logo = None\n",
    "    fig.toolbar_location = None\n",
    "\n",
    "    if log_scale:\n",
    "        for axis in [fig.xaxis, fig.yaxis]:\n",
    "            axis[0].ticker.base = log_scale\n",
    "            axis[0].formatter.ticker = axis[0].ticker\n",
    "\n",
    "    fig.grid.visible = (grid == 'grid')\n",
    "    fig.grid.name = 'grid'\n",
    "    \n",
    "    lasso = bokeh.models.LassoSelectTool(select_every_mousemove=False)\n",
    "    fig.add_tools(lasso)\n",
    "    \n",
    "    if initial_xy_names is None:\n",
    "        x_name, y_name = numerical_cols[:2]\n",
    "    else:\n",
    "        x_name, y_name = initial_xy_names\n",
    "    \n",
    "    fig.xaxis.name = 'x_axis'\n",
    "    fig.yaxis.name = 'y_axis'\n",
    "    fig.xaxis.axis_label = x_name\n",
    "    fig.yaxis.axis_label = y_name\n",
    "    for axis in (fig.xaxis, fig.yaxis):\n",
    "        axis.axis_label_text_font_size = '{0}pt'.format(axis_label_size)\n",
    "        axis.axis_label_text_font_style = 'normal'\n",
    "\n",
    "    scatter_source.data['x'] = scatter_source.data[x_name]\n",
    "    scatter_source.data['y'] = scatter_source.data[y_name]\n",
    "    \n",
    "    scatter_source.data['index'] = list(df.index)\n",
    "\n",
    "    scatter_source.data['_no_color'] = ['rgba(0, 0, 0, 1.0)' for _ in scatter_source.data['x']]\n",
    "    \n",
    "    if color_by is None:\n",
    "        color_by = '_no_color'\n",
    "        show_color_by_menu = False\n",
    "    else:\n",
    "        show_color_by_menu = True\n",
    "\n",
    "    if isinstance(color_by, basestring):\n",
    "        color_options = ['', color_by]\n",
    "    else:\n",
    "        show_color_by_menu = True\n",
    "        color_options = [''] + list(color_by)\n",
    "    \n",
    "    scatter_source.data['_color'] = scatter_source.data[color_options[1]]\n",
    "    \n",
    "    if label_by is None:\n",
    "        label_by = df.index.name\n",
    "\n",
    "    if isinstance(label_by, basestring):\n",
    "        show_label_by_menu = False\n",
    "        label_options = [label_by]\n",
    "    else:\n",
    "        show_label_by_menu = True\n",
    "        label_options = list(label_by)\n",
    "    \n",
    "    scatter_source.data['_label'] = scatter_source.data[label_options[0]]\n",
    "\n",
    "    if isinstance(marker_size, (int, long, float)):\n",
    "        show_marker_size_menu = False\n",
    "        size_widget_type = 'slider'\n",
    "    else:\n",
    "        if isinstance(marker_size, basestring):\n",
    "            size_options = ['', marker_size]\n",
    "        else:\n",
    "            size_options = [''] + list(marker_size)\n",
    "    \n",
    "        show_marker_size_menu = True\n",
    "        size_widget_type = 'menu'\n",
    "        marker_size = '_size'\n",
    "        scatter_source.data[marker_size] = scatter_source.data[size_options[1]]\n",
    "\n",
    "        scatter_source.data['_uniform_size'] = [6]*len(scatter_source.data[marker_size])\n",
    "\n",
    "    scatter_source.selected = build_selected(initial_indices)\n",
    "\n",
    "    scatter = fig.scatter('x',\n",
    "                          'y',\n",
    "                          source=scatter_source,\n",
    "                          size=marker_size,\n",
    "                          fill_color='_color',\n",
    "                          fill_alpha=0.5,\n",
    "                          line_color=None,\n",
    "                          nonselection_color='_color',\n",
    "                          nonselection_alpha=0.1,\n",
    "                          selection_color='color',\n",
    "                          selection_alpha=0.9,\n",
    "                          name='scatter',\n",
    "                         )\n",
    "    \n",
    "    if log_scale:\n",
    "        nonzero = df[df > 0]\n",
    "        overall_max = nonzero.max(numeric_only=True).max()\n",
    "        overall_min = nonzero.min(numeric_only=True).min()\n",
    "        overall_buffer = (overall_max - overall_min) * 0.05\n",
    "        initial = (overall_min * 0.1, overall_max * 10)\n",
    "        bounds = (overall_min * 0.001, overall_max * 1000)\n",
    "    \n",
    "        def log(x):\n",
    "            return np.log(x) / np.log(log_scale)\n",
    "\n",
    "        bins = {}\n",
    "        for name in numerical_cols:\n",
    "            if identical_bins:\n",
    "                left = overall_min \n",
    "                right = overall_max\n",
    "            else:\n",
    "                name_min = nonzero[name].min()\n",
    "                name_max = nonzero[name].max()\n",
    "                name_buffer = (name_max - name_min) * 0.05\n",
    "                left = name_min\n",
    "                right = name_max\n",
    "\n",
    "            bins[name] = list(np.logspace(log(left), log(right), num_bins))\n",
    "\n",
    "    else:\n",
    "        overall_max = df.max(numeric_only=True).max()\n",
    "        overall_min = df.min(numeric_only=True).min()\n",
    "        overall_buffer = (overall_max - overall_min) * 0.05\n",
    "        \n",
    "        extent = overall_max - overall_min\n",
    "        overhang = extent * 0.05\n",
    "        max_overhang = extent * 0.5\n",
    "\n",
    "        initial = (overall_min - overhang, overall_max + overhang)\n",
    "        bounds = (overall_min - max_overhang, overall_max + max_overhang)\n",
    "        \n",
    "        bins = {}\n",
    "        for name in numerical_cols:\n",
    "            if identical_bins:\n",
    "                left = overall_min - overall_buffer\n",
    "                right = overall_max + overall_buffer\n",
    "            else:\n",
    "                name_min = df[name].min()\n",
    "                name_max = df[name].max()\n",
    "                name_buffer = (name_max - name_min) * 0.05\n",
    "                left = name_min - name_buffer\n",
    "                right = name_max + name_buffer\n",
    "            \n",
    "            bins[name] = list(np.linspace(left, right, num_bins))\n",
    "\n",
    "    if data_lims is not None:\n",
    "        initial = data_lims\n",
    "        bounds = data_lims\n",
    "\n",
    "    diagonals_visible = (grid == 'diagonal')\n",
    "\n",
    "    fig.line(x=bounds, y=bounds,\n",
    "             color='black',\n",
    "             nonselection_color='black',\n",
    "             alpha=0.4,\n",
    "             nonselection_alpha=0.4,\n",
    "             name='diagonal',\n",
    "             visible=diagonals_visible,\n",
    "            )\n",
    "\n",
    "    if log_scale:\n",
    "        upper_ys = np.array(bounds) * 10\n",
    "        lower_ys = np.array(bounds) * 0.1\n",
    "    else:\n",
    "        upper_ys = np.array(bounds) + 1\n",
    "        lower_ys = np.array(bounds) - 1\n",
    "\n",
    "    line_kwargs = dict(\n",
    "        color='black',\n",
    "        nonselection_color='black',\n",
    "        alpha=0.4,\n",
    "        nonselection_alpha=0.4,\n",
    "        line_dash=[5, 5],\n",
    "        name='diagonal',\n",
    "        visible=diagonals_visible,\n",
    "    ) \n",
    "    fig.line(x=bounds, y=upper_ys, **line_kwargs)\n",
    "    fig.line(x=bounds, y=lower_ys, **line_kwargs)\n",
    "    \n",
    "    if volcano:\n",
    "        fig.y_range = bokeh.models.Range1d(-0.1, 8)\n",
    "        fig.x_range = bokeh.models.Range1d(-1, 1)\n",
    "    else:\n",
    "        if zoom_to_initial_data:\n",
    "            x_min, x_max = bins[x_name][0], bins[x_name][-1]\n",
    "            y_min, y_max = bins[y_name][0], bins[y_name][-1]\n",
    "        else:\n",
    "            x_min, x_max = initial\n",
    "            y_min, y_max = initial\n",
    "\n",
    "        fig.y_range = bokeh.models.Range1d(y_min, y_max)\n",
    "        fig.x_range = bokeh.models.Range1d(x_min, x_max)\n",
    "\n",
    "    fig.x_range.name = 'x_range'\n",
    "    fig.y_range.name = 'y_range'\n",
    "    \n",
    "    lower_bound, upper_bound = bounds\n",
    "    range_kwargs = dict(lower_bound=lower_bound, upper_bound=upper_bound)\n",
    "    \n",
    "    fig.x_range.callback = build_callback('scatter_range', format_kwargs=range_kwargs)\n",
    "    fig.y_range.callback = build_callback('scatter_range', format_kwargs=range_kwargs)\n",
    "    \n",
    "    fig.outline_line_color = 'black'\n",
    "\n",
    "    scatter.selection_glyph.fill_color = 'orange'\n",
    "    scatter.selection_glyph.line_color = None\n",
    "    scatter.nonselection_glyph.line_color = None\n",
    "\n",
    "    # Make marginal histograms.\n",
    "\n",
    "    histogram_source = bokeh.models.ColumnDataSource(name='histogram_source')\n",
    "    histogram_source.data = {\n",
    "        'zero': [0]*(num_bins - 1),\n",
    "    }\n",
    "\n",
    "    for name in numerical_cols:\n",
    "        histogram_source.data.update({\n",
    "            '{0}_bins_left'.format(name): bins[name][:-1],\n",
    "            '{0}_bins_right'.format(name): bins[name][1:],\n",
    "        })\n",
    "\n",
    "    max_count = 0\n",
    "    for name in numerical_cols:\n",
    "        counts, _ = np.histogram(df[name].dropna(), bins=bins[name])\n",
    "        max_count = max(max(counts), max_count)\n",
    "        histogram_source.data['{0}_all'.format(name)] = list(counts)\n",
    "\n",
    "    if log_scale:\n",
    "        axis_type = 'log'\n",
    "    else:\n",
    "        axis_type = 'linear'\n",
    "\n",
    "    hist_figs = {\n",
    "        'x': bokeh.plotting.figure(width=size, height=100,\n",
    "                                   x_range=fig.x_range,\n",
    "                                   x_axis_type=axis_type,\n",
    "                                   name='hists_x',\n",
    "                                  ),\n",
    "        'y': bokeh.plotting.figure(width=100, height=size,\n",
    "                                   y_range=fig.y_range,\n",
    "                                   y_axis_type=axis_type,\n",
    "                                   name='hists_y',\n",
    "                                  ),\n",
    "    }\n",
    "\n",
    "    for axis, name in [('x', x_name), ('y', y_name)]:\n",
    "        for data_type in ['all', 'bins_left', 'bins_right']:\n",
    "            left_key = '{0}_{1}'.format(axis, data_type)\n",
    "            right_key = '{0}_{1}'.format(name, data_type)\n",
    "            histogram_source.data[left_key] = histogram_source.data[right_key]\n",
    "\n",
    "        initial_vals = df[name].iloc[initial_indices]\n",
    "        initial_counts, _ = np.histogram(initial_vals.dropna(), bins[name])\n",
    "    \n",
    "        histogram_source.data['{0}_selected'.format(axis)] = initial_counts\n",
    "\n",
    "    initial_hist_alpha = 0.1 if len(initial_indices) > 0 else 0.2\n",
    "    quads = {}\n",
    "    quads['x_all'] = hist_figs['x'].quad(left='x_bins_left',\n",
    "                                         right='x_bins_right',\n",
    "                                         bottom='zero',\n",
    "                                         top='x_all',\n",
    "                                         source=histogram_source,\n",
    "                                         color='black',\n",
    "                                         alpha=initial_hist_alpha,\n",
    "                                         line_color=None,\n",
    "                                         name='hist_x_all',\n",
    "                                        )\n",
    "\n",
    "    quads['x_selected'] = hist_figs['x'].quad(left='x_bins_left',\n",
    "                                              right='x_bins_right',\n",
    "                                              bottom='zero',\n",
    "                                              top='x_selected',\n",
    "                                              source=histogram_source,\n",
    "                                              color='orange',\n",
    "                                              alpha=0.8,\n",
    "                                              line_color=None,\n",
    "                                             )\n",
    "\n",
    "    quads['y_all'] = hist_figs['y'].quad(top='y_bins_left',\n",
    "                                         bottom='y_bins_right',\n",
    "                                         left='zero',\n",
    "                                         right='y_all',\n",
    "                                         source=histogram_source,\n",
    "                                         color='black',\n",
    "                                         alpha=initial_hist_alpha,\n",
    "                                         line_color=None,\n",
    "                                         name='hist_y_all',\n",
    "                                        )\n",
    "\n",
    "    quads['y_selected'] = hist_figs['y'].quad(top='y_bins_left',\n",
    "                                              bottom='y_bins_right',\n",
    "                                              left='zero',\n",
    "                                              right='y_selected',\n",
    "                                              source=histogram_source,\n",
    "                                              color='orange',\n",
    "                                              alpha=0.8,\n",
    "                                              line_color=None,\n",
    "                                             )\n",
    "\n",
    "    # Poorly-understood bokeh behavior causes selection changes to sometimes\n",
    "    # be broadcast to histogram_source. To prevent this from having any visual\n",
    "    # effect, remove any difference in selection/nonselection glyphs.\n",
    "    for quad in quads.values():\n",
    "        quad.selection_glyph = quad.glyph\n",
    "        quad.nonselection_glyph = quad.glyph\n",
    "\n",
    "    if identical_bins:\n",
    "        x_end = max_count\n",
    "        y_end = max_count\n",
    "    else:\n",
    "        x_end = max(histogram_source.data['x_all'])\n",
    "        y_end = max(histogram_source.data['y_all'])\n",
    "\n",
    "    hist_figs['x'].y_range = bokeh.models.Range1d(name='hist_x_range',\n",
    "                                                  start=0,\n",
    "                                                  end=x_end,\n",
    "                                                  bounds='auto',\n",
    "                                                 )\n",
    "    hist_figs['y'].x_range = bokeh.models.Range1d(name='hist_y_range',\n",
    "                                                  start=0,\n",
    "                                                  end=y_end,\n",
    "                                                  bounds='auto',\n",
    "                                                 )\n",
    "\n",
    "    for hist_fig in hist_figs.values():\n",
    "        hist_fig.outline_line_color = None\n",
    "        hist_fig.axis.visible = False\n",
    "        hist_fig.grid.visible = False\n",
    "        hist_fig.min_border = 0\n",
    "        hist_fig.toolbar_location = None\n",
    "\n",
    "    # Configure tooltips that pop up when hovering over a point.\n",
    "    \n",
    "    hover = bokeh.models.HoverTool()\n",
    "    hover.tooltips = [\n",
    "        (df.index.name, '@{0}'.format(df.index.name)),\n",
    "    ]\n",
    "    for key in hover_keys:\n",
    "        hover.tooltips.append((key, '@{0}'.format(key)))\n",
    "    fig.add_tools(hover)\n",
    "\n",
    "    # Set up the table.\n",
    "\n",
    "    table_col_names = [df.index.name] + table_keys\n",
    "    columns = []\n",
    "    for col_name in table_col_names:\n",
    "        lengths = [len(str(v)) for v in scatter_source.data[col_name]]\n",
    "        mean_length = np.mean(lengths)\n",
    "\n",
    "        if col_name in numerical_cols:\n",
    "            formatter = bokeh.models.widgets.NumberFormatter(format='0.00')\n",
    "            width = 50\n",
    "        else:\n",
    "            formatter = None\n",
    "            width = min(500, int(12 * mean_length))\n",
    "\n",
    "        column = bokeh.models.widgets.TableColumn(field=col_name,\n",
    "                                                  title=col_name,\n",
    "                                                  formatter=formatter,\n",
    "                                                  width=width,\n",
    "                                                 )\n",
    "        columns.append(column)\n",
    "\n",
    "    filtered_data = {k: [scatter_source.data[k][i] for i in initial_indices]\n",
    "                     for k in scatter_source.data\n",
    "                    }\n",
    "    \n",
    "    filtered_source = bokeh.models.ColumnDataSource(data=filtered_data, name='labels_source')\n",
    "    \n",
    "    table = bokeh.models.widgets.DataTable(source=filtered_source,\n",
    "                                           columns=columns,\n",
    "                                           width=2 * size if heatmap else size,\n",
    "                                           height=600,\n",
    "                                           sortable=False,\n",
    "                                           name='table',\n",
    "                                           row_headers=False,\n",
    "                                          )\n",
    "    \n",
    "    # Callback to filter the table when selection changes.\n",
    "    scatter_source.callback = build_callback('scatter_selection')\n",
    "    \n",
    "    labels = bokeh.models.LabelSet(x='x',\n",
    "                                   y='y',\n",
    "                                   text='_label',\n",
    "                                   level='glyph',\n",
    "                                   x_offset=0,\n",
    "                                   y_offset=2,\n",
    "                                   source=filtered_source,\n",
    "                                   text_font_size='8pt',\n",
    "                                   name='labels',\n",
    "                                  )\n",
    "    fig.add_layout(labels)\n",
    "    \n",
    "    # Set up menus or heatmap to select columns from df to put on x- and y-axis.\n",
    "\n",
    "    if heatmap:\n",
    "        norm = matplotlib.colors.Normalize(vmin=-1, vmax=1)\n",
    "\n",
    "        def r_to_color(r):\n",
    "            color = matplotlib.colors.rgb2hex(matplotlib.cm.RdBu_r(norm(r)))\n",
    "            return color\n",
    "\n",
    "        data = {\n",
    "            'x': [],\n",
    "            'x_name': [],\n",
    "            'y': [],\n",
    "            'y_name': [],\n",
    "            'r': [],\n",
    "            'color': [],\n",
    "        }\n",
    "\n",
    "        correlations = df.corr()\n",
    "        for y, row in enumerate(numerical_cols):\n",
    "            for x, col in enumerate(numerical_cols):\n",
    "                r = correlations[row][col]\n",
    "                data['r'].append(r)\n",
    "                data['x'].append(x)\n",
    "                data['x_name'].append(col)\n",
    "                data['y'].append(y)\n",
    "                data['y_name'].append(row)\n",
    "                data['color'].append(r_to_color(r))\n",
    "                \n",
    "        heatmap_source = bokeh.models.ColumnDataSource(data)\n",
    "        num_exps = len(numerical_cols)\n",
    "        heatmap_size = size - 100\n",
    "        heatmap_fig = bokeh.plotting.figure(tools='tap',\n",
    "                                            x_range=(-0.5, num_exps - 0.5),\n",
    "                                            y_range=(num_exps - 0.5, -0.5),\n",
    "                                            width=heatmap_size, height=heatmap_size,\n",
    "                                            toolbar_location=None,\n",
    "                                           )\n",
    "\n",
    "        heatmap_fig.grid.visible = False\n",
    "        rects = heatmap_fig.rect(x='x', y='y',\n",
    "                                 line_color=None,\n",
    "                                 hover_line_color='black',\n",
    "                                 hover_fill_color='color',\n",
    "                                 selection_fill_color='color',\n",
    "                                 nonselection_fill_color='color',\n",
    "                                 nonselection_fill_alpha=1,\n",
    "                                 nonselection_line_color=None,\n",
    "                                 selection_line_color='black',\n",
    "                                 line_width=5,\n",
    "                                 fill_color='color',\n",
    "                                 source=heatmap_source,\n",
    "                                 width=1, height=1,\n",
    "                                )\n",
    "\n",
    "        hover = bokeh.models.HoverTool()\n",
    "        hover.tooltips = [\n",
    "            ('X', '@x_name'),\n",
    "            ('Y', '@y_name'),\n",
    "            ('r', '@r'),\n",
    "        ]\n",
    "        heatmap_fig.add_tools(hover)\n",
    "\n",
    "        first_row = [heatmap_fig]\n",
    "        heatmap_source.callback = build_callback('scatter_heatmap')\n",
    "\n",
    "        code = '''\n",
    "        dict = {dict}\n",
    "        return dict[tick].slice(0, 15)\n",
    "        '''.format(dict=dict(enumerate(numerical_cols)))\n",
    "        \n",
    "        for ax in [heatmap_fig.xaxis, heatmap_fig.yaxis]:\n",
    "            ax.ticker = bokeh.models.FixedTicker(ticks=range(num_exps))\n",
    "            ax.formatter = bokeh.models.FuncTickFormatter(code=code)\n",
    "            ax.major_label_text_font_size = '8pt'\n",
    "\n",
    "        heatmap_fig.xaxis.major_label_orientation = np.pi / 4\n",
    "\n",
    "        # Turn off black lines on bottom and left.\n",
    "        for axis in (heatmap_fig.xaxis, heatmap_fig.yaxis):\n",
    "            axis.axis_line_color = None\n",
    "\n",
    "        name_pairs = zip(heatmap_source.data['x_name'], heatmap_source.data['y_name'])\n",
    "        initial_index = name_pairs.index((x_name, y_name))\n",
    "        heatmap_source.selected = build_selected([initial_index])\n",
    "\n",
    "        heatmap_fig.min_border = min_border\n",
    "        \n",
    "    else:\n",
    "        x_menu = bokeh.models.widgets.MultiSelect(title='X',\n",
    "                                                  options=numerical_cols,\n",
    "                                                  value=[x_name],\n",
    "                                                  size=min(6, len(numerical_cols)),\n",
    "                                                  name='x_menu',\n",
    "                                               )\n",
    "        y_menu = bokeh.models.widgets.MultiSelect(title='Y',\n",
    "                                                  options=numerical_cols,\n",
    "                                                  value=[y_name],\n",
    "                                                  size=min(6, len(numerical_cols)),\n",
    "                                                  name='y_menu',\n",
    "                                               )\n",
    "\n",
    "        menu_callback = build_callback('scatter_menu')\n",
    "        x_menu.callback = menu_callback\n",
    "        y_menu.callback = menu_callback\n",
    "        \n",
    "        first_row = [bokeh.layouts.widgetbox([x_menu, y_menu])],\n",
    "    \n",
    "    # Button to toggle labels.\n",
    "    label_button = bokeh.models.widgets.Toggle(label='label selected points',\n",
    "                                               width=50,\n",
    "                                               active=True,\n",
    "                                               name='label_button',\n",
    "                                              )\n",
    "    label_button.callback = bokeh.models.CustomJS(args={'labels': labels},\n",
    "                                                  code='labels.text_alpha = 1 - labels.text_alpha;',\n",
    "                                                 )\n",
    "    \n",
    "    # Button to zoom to current data limits.\n",
    "    zoom_to_data_button = bokeh.models.widgets.Button(label='zoom to data limits',\n",
    "                                                      width=50,\n",
    "                                                      name='zoom_button',\n",
    "                                                     )\n",
    "    def bool_to_js(b):\n",
    "        return 'true' if b else 'false'\n",
    "\n",
    "    format_kwargs = dict(log_scale=bool_to_js(log_scale),\n",
    "                         identical_bins=bool_to_js(identical_bins),\n",
    "                        )\n",
    "    zoom_to_data_button.callback = build_callback('scatter_zoom_to_data',\n",
    "                                                  format_kwargs=format_kwargs,\n",
    "                                                 )\n",
    "\n",
    "    # Menu to choose label source.\n",
    "    label_menu = bokeh.models.widgets.Select(title='Label by:',\n",
    "                                             options=label_options,\n",
    "                                             value=label_options[0],\n",
    "                                             name='label_menu',\n",
    "                                            )\n",
    "    label_menu.callback = build_callback('scatter_label')\n",
    "\n",
    "    # Menu to choose color source.\n",
    "    color_menu = bokeh.models.widgets.Select(title='Color by:',\n",
    "                                             options=color_options,\n",
    "                                             value=color_options[1],\n",
    "                                             name='color_menu',\n",
    "                                            )\n",
    "    color_menu.callback = build_callback('scatter_color')\n",
    "\n",
    "    # Radio group to choose whether to draw a vertical/horizontal grid or\n",
    "    # diagonal guide lines. \n",
    "    options = ['grid', 'diagonal', 'none']\n",
    "    active = options.index(grid)\n",
    "    grid_options = bokeh.models.widgets.RadioGroup(labels=options,\n",
    "                                                   active=active,\n",
    "                                                   name='grid_radio_buttons',\n",
    "                                                  )\n",
    "    grid_options.callback = build_callback('scatter_grid')\n",
    "\n",
    "    text_input = bokeh.models.widgets.TextInput(title='Search:', name='search')\n",
    "    text_input.callback = build_callback('scatter_search',\n",
    "                                         format_kwargs=dict(column_names=str(object_cols)),\n",
    "                                        )\n",
    "\n",
    "    case_sensitive = bokeh.models.widgets.CheckboxGroup(labels=['Case sensitive'],\n",
    "                                                        active=[],\n",
    "                                                        name='case_sensitive',\n",
    "                                                       )\n",
    "    case_sensitive.callback = build_callback('case_sensitive')\n",
    "\n",
    "    # Menu to select a subset of points from a columns of bools.\n",
    "    subset_options = [''] + bool_cols\n",
    "    subset_menu = bokeh.models.widgets.Select(title='Select subset:',\n",
    "                                              options=subset_options,\n",
    "                                              value='',\n",
    "                                              name='subset_menu',\n",
    "                                             )\n",
    "    subset_menu.callback = build_callback('scatter_subset_menu',\n",
    "                                          format_kwargs=dict(subset_indices=str(subset_indices)),\n",
    "                                         )\n",
    "\n",
    "    # Button to dump table to file.\n",
    "    save_button = bokeh.models.widgets.Button(label='Save table to file',\n",
    "                                              width=50,\n",
    "                                              name='save_button',\n",
    "                                             )\n",
    "    save_button.callback = build_callback('scatter_save_button',\n",
    "                                          format_kwargs=dict(column_names=str(table_col_names)),\n",
    "                                         )\n",
    "\n",
    "    if alpha_widget_type == 'slider':\n",
    "        alpha_widget = bokeh.models.Slider(start=0.,\n",
    "                                           end=1.,\n",
    "                                           value=0.5,\n",
    "                                           step=.05,\n",
    "                                           title='alpha',\n",
    "                                           name='alpha',\n",
    "                                          )\n",
    "    elif alpha_widget_type == 'text':\n",
    "        alpha_widget = bokeh.models.TextInput(title='alpha', name='alpha', value='0.5')\n",
    "    else:\n",
    "        raise ValueError('{0} not a valid alpha_widget_type value'.format(alpha_widget_type))\n",
    "\n",
    "    alpha_widget.callback = build_callback('scatter_alpha')\n",
    "    \n",
    "    if size_widget_type == 'slider':\n",
    "        size_widget = bokeh.models.Slider(start=1,\n",
    "                                          end=20.,\n",
    "                                          value=marker_size,\n",
    "                                          step=1,\n",
    "                                          title='marker size',\n",
    "                                          name='marker_size',\n",
    "                                         )\n",
    "        size_widget.callback = build_callback('scatter_size')\n",
    "    else:\n",
    "        size_widget = bokeh.models.widgets.Select(title='Size by:',\n",
    "                                                  options=size_options,\n",
    "                                                  value=size_options[1],\n",
    "                                                  name='marker_size',\n",
    "                                                 )\n",
    "        size_widget.callback = build_callback('scatter_size_menu')\n",
    "\n",
    "\n",
    "    fig.min_border = 1\n",
    "\n",
    "    widgets = [\n",
    "        label_button,\n",
    "        zoom_to_data_button,\n",
    "        label_menu,\n",
    "        color_menu,\n",
    "        alpha_widget,\n",
    "        size_widget,\n",
    "        grid_options,\n",
    "        text_input,\n",
    "        case_sensitive,\n",
    "        subset_menu,\n",
    "        save_button,\n",
    "    ]\n",
    "\n",
    "    if 'table' in hide_widgets:\n",
    "        hide_widgets.add('save_button')\n",
    "\n",
    "    if 'search' in hide_widgets:\n",
    "        hide_widgets.add('case_sensitive')\n",
    "\n",
    "    if not show_color_by_menu:\n",
    "        hide_widgets.add('color_menu')\n",
    "\n",
    "    if not show_label_by_menu:\n",
    "        hide_widgets.add('label_menu')\n",
    "\n",
    "    if len(subset_options) == 1:\n",
    "        hide_widgets.add('subset_menu')\n",
    "\n",
    "    widgets = [w for w in widgets if w.name not in hide_widgets]\n",
    "\n",
    "    if not heatmap:\n",
    "        widgets = [x_menu, y_menu] + widgets\n",
    "\n",
    "    widget_box = bokeh.layouts.widgetbox(children=widgets)\n",
    "\n",
    "    toolbar = bokeh.models.ToolbarBox(tools=fig.toolbar.tools)\n",
    "    toolbar.logo = None\n",
    "\n",
    "    columns = [\n",
    "        bokeh.layouts.column(children=[hist_figs['x'], fig]),\n",
    "        bokeh.layouts.column(children=[bokeh.layouts.Spacer(height=100), hist_figs['y']]),\n",
    "        bokeh.layouts.column(children=[bokeh.layouts.Spacer(height=100), toolbar]),\n",
    "        bokeh.layouts.column(children=[bokeh.layouts.Spacer(height=min_border),\n",
    "                                       widget_box,\n",
    "                                      ]),\n",
    "    ]\n",
    "\n",
    "    if heatmap:\n",
    "        heatmap_column = bokeh.layouts.column(children=[bokeh.layouts.Spacer(height=100), heatmap_fig])\n",
    "        columns = columns[:-1] + [heatmap_column] + columns[-1:]\n",
    "\n",
    "    rows = [\n",
    "        bokeh.layouts.row(children=columns),\n",
    "    ]\n",
    "    if 'table' not in hide_widgets:\n",
    "        rows.append(table)\n",
    "\n",
    "    full_layout = bokeh.layouts.column(children=rows)\n",
    "    output_notebook()\n",
    "    show(full_layout)\n",
    "\n",
    "    if return_layout:\n",
    "        return full_layout"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "toggle = '''\n",
    "<script>\n",
    "  function code_toggle() {\n",
    "    if (code_shown){\n",
    "      $('div.input').hide('100');\n",
    "      $('#toggleButton').val('Show Code')\n",
    "    } else {\n",
    "      $('div.input').show('100');\n",
    "      $('#toggleButton').val('Hide Code')\n",
    "    }\n",
    "    code_shown = !code_shown\n",
    "  }\n",
    "\n",
    "  $( document ).ready(function(){\n",
    "    code_shown=false;\n",
    "    $('div.input').hide()\n",
    "  });\n",
    "</script>\n",
    "<form action=\"javascript:code_toggle()\"><input type=\"submit\" id=\"toggleButton\" value=\"Show Code\"></form>\n",
    "'''\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "\n",
       "    <div class=\"bk-root\">\n",
       "        <a href=\"http://bokeh.pydata.org\" target=\"_blank\" class=\"bk-logo bk-logo-small bk-logo-notebook\"></a>\n",
       "        <span id=\"c23ec96f-3487-46c8-87ad-98f00d36e0b2\">Loading BokehJS ...</span>\n",
       "    </div>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/javascript": [
       "\n",
       "(function(global) {\n",
       "  function now() {\n",
       "    return new Date();\n",
       "  }\n",
       "\n",
       "  var force = true;\n",
       "\n",
       "  if (typeof (window._bokeh_onload_callbacks) === \"undefined\" || force === true) {\n",
       "    window._bokeh_onload_callbacks = [];\n",
       "    window._bokeh_is_loading = undefined;\n",
       "  }\n",
       "\n",
       "\n",
       "  \n",
       "  if (typeof (window._bokeh_timeout) === \"undefined\" || force === true) {\n",
       "    window._bokeh_timeout = Date.now() + 5000;\n",
       "    window._bokeh_failed_load = false;\n",
       "  }\n",
       "\n",
       "  var NB_LOAD_WARNING = {'data': {'text/html':\n",
       "     \"<div style='background-color: #fdd'>\\n\"+\n",
       "     \"<p>\\n\"+\n",
       "     \"BokehJS does not appear to have successfully loaded. If loading BokehJS from CDN, this \\n\"+\n",
       "     \"may be due to a slow or bad network connection. Possible fixes:\\n\"+\n",
       "     \"</p>\\n\"+\n",
       "     \"<ul>\\n\"+\n",
       "     \"<li>re-rerun `output_notebook()` to attempt to load from CDN again, or</li>\\n\"+\n",
       "     \"<li>use INLINE resources instead, as so:</li>\\n\"+\n",
       "     \"</ul>\\n\"+\n",
       "     \"<code>\\n\"+\n",
       "     \"from bokeh.resources import INLINE\\n\"+\n",
       "     \"output_notebook(resources=INLINE)\\n\"+\n",
       "     \"</code>\\n\"+\n",
       "     \"</div>\"}};\n",
       "\n",
       "  function display_loaded() {\n",
       "    if (window.Bokeh !== undefined) {\n",
       "      var el = document.getElementById(\"c23ec96f-3487-46c8-87ad-98f00d36e0b2\");\n",
       "      el.textContent = \"BokehJS \" + Bokeh.version + \" successfully loaded.\";\n",
       "    } else if (Date.now() < window._bokeh_timeout) {\n",
       "      setTimeout(display_loaded, 100)\n",
       "    }\n",
       "  }\n",
       "\n",
       "  function run_callbacks() {\n",
       "    try {\n",
       "      window._bokeh_onload_callbacks.forEach(function(callback) { callback() });\n",
       "    }\n",
       "    finally {\n",
       "      delete window._bokeh_onload_callbacks\n",
       "    }\n",
       "    console.info(\"Bokeh: all callbacks have finished\");\n",
       "  }\n",
       "\n",
       "  function load_libs(js_urls, callback) {\n",
       "    window._bokeh_onload_callbacks.push(callback);\n",
       "    if (window._bokeh_is_loading > 0) {\n",
       "      console.log(\"Bokeh: BokehJS is being loaded, scheduling callback at\", now());\n",
       "      return null;\n",
       "    }\n",
       "    if (js_urls == null || js_urls.length === 0) {\n",
       "      run_callbacks();\n",
       "      return null;\n",
       "    }\n",
       "    console.log(\"Bokeh: BokehJS not loaded, scheduling load and callback at\", now());\n",
       "    window._bokeh_is_loading = js_urls.length;\n",
       "    for (var i = 0; i < js_urls.length; i++) {\n",
       "      var url = js_urls[i];\n",
       "      var s = document.createElement('script');\n",
       "      s.src = url;\n",
       "      s.async = false;\n",
       "      s.onreadystatechange = s.onload = function() {\n",
       "        window._bokeh_is_loading--;\n",
       "        if (window._bokeh_is_loading === 0) {\n",
       "          console.log(\"Bokeh: all BokehJS libraries loaded\");\n",
       "          run_callbacks()\n",
       "        }\n",
       "      };\n",
       "      s.onerror = function() {\n",
       "        console.warn(\"failed to load library \" + url);\n",
       "      };\n",
       "      console.log(\"Bokeh: injecting script tag for BokehJS library: \", url);\n",
       "      document.getElementsByTagName(\"head\")[0].appendChild(s);\n",
       "    }\n",
       "  };var element = document.getElementById(\"c23ec96f-3487-46c8-87ad-98f00d36e0b2\");\n",
       "  if (element == null) {\n",
       "    console.log(\"Bokeh: ERROR: autoload.js configured with elementid 'c23ec96f-3487-46c8-87ad-98f00d36e0b2' but no matching script tag was found. \")\n",
       "    return false;\n",
       "  }\n",
       "\n",
       "  var js_urls = [\"https://cdn.pydata.org/bokeh/dev/bokeh-0.12.7dev3.min.js\", \"https://cdn.pydata.org/bokeh/dev/bokeh-widgets-0.12.7dev3.min.js\"];\n",
       "\n",
       "  var inline_js = [\n",
       "    function(Bokeh) {\n",
       "      Bokeh.set_log_level(\"info\");\n",
       "    },\n",
       "    \n",
       "    function(Bokeh) {\n",
       "      \n",
       "    },\n",
       "    \n",
       "    function(Bokeh) {\n",
       "      \n",
       "      document.getElementById(\"c23ec96f-3487-46c8-87ad-98f00d36e0b2\").textContent = \"BokehJS is loading...\";\n",
       "    },\n",
       "    function(Bokeh) {\n",
       "      console.log(\"Bokeh: injecting CSS: https://cdn.pydata.org/bokeh/dev/bokeh-0.12.7dev3.min.css\");\n",
       "      Bokeh.embed.inject_css(\"https://cdn.pydata.org/bokeh/dev/bokeh-0.12.7dev3.min.css\");\n",
       "      console.log(\"Bokeh: injecting CSS: https://cdn.pydata.org/bokeh/dev/bokeh-widgets-0.12.7dev3.min.css\");\n",
       "      Bokeh.embed.inject_css(\"https://cdn.pydata.org/bokeh/dev/bokeh-widgets-0.12.7dev3.min.css\");\n",
       "    }\n",
       "  ];\n",
       "\n",
       "  function run_inline_js() {\n",
       "    \n",
       "    if ((window.Bokeh !== undefined) || (force === true)) {\n",
       "      for (var i = 0; i < inline_js.length; i++) {\n",
       "        inline_js[i](window.Bokeh);\n",
       "      }if (force === true) {\n",
       "        display_loaded();\n",
       "      }} else if (Date.now() < window._bokeh_timeout) {\n",
       "      setTimeout(run_inline_js, 100);\n",
       "    } else if (!window._bokeh_failed_load) {\n",
       "      console.log(\"Bokeh: BokehJS failed to load within specified timeout.\");\n",
       "      window._bokeh_failed_load = true;\n",
       "    } else if (force !== true) {\n",
       "      var cell = $(document.getElementById(\"c23ec96f-3487-46c8-87ad-98f00d36e0b2\")).parents('.cell').data().cell;\n",
       "      cell.output_area.append_execute_result(NB_LOAD_WARNING)\n",
       "    }\n",
       "\n",
       "  }\n",
       "\n",
       "  if (window._bokeh_is_loading === 0) {\n",
       "    console.log(\"Bokeh: BokehJS loaded, going straight to plotting\");\n",
       "    run_inline_js();\n",
       "  } else {\n",
       "    load_libs(js_urls, function() {\n",
       "      console.log(\"Bokeh: BokehJS plotting callback run at\", now());\n",
       "      run_inline_js();\n",
       "    });\n",
       "  }\n",
       "}(this));"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "IOPub data rate exceeded.\n",
      "The notebook server will temporarily stop sending output\n",
      "to the client in order to avoid crashing it.\n",
      "To change this limit, set the config variable\n",
      "`--NotebookApp.iopub_data_rate_limit`.\n"
     ]
    }
   ],
   "source": [
    "IPython.iopub_data_rate_limit = 999999999999999999999999999999999999999999999999999999999999999999999999999999999\n",
    "toggle_cell = IPython.display.HTML(toggle)\n",
    "scatter(filename='example_df.txt', heatmap=False, log_scale=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
